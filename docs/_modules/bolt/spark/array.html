


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bolt.spark.array</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/styles.css" type="text/css" />
  

  
    <link rel="top" title="None" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> bolt
        

        
          
          <img src="../../../_static/header-logo-small.svg" class="logo" />
        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../overview-motivation.html">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview-methods.html">Core API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview-related.html">Related work</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../overview-thanks.html">Thanks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#backends">Backends</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#local">Local</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installation.html#spark">Spark</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#docker-image">Docker image</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../construction.html">Construction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../construction.html#local">Local</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../construction.html#spark">Spark</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../construction.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../construction.html#detailed-api">Detailed API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../spark.html">Spark</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../spark-overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../spark-design.html">Design</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../spark-design.html#swapping">Swapping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../spark-design.html#transposing-reshaping">Transposing / reshaping</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../spark-design.html#stacking-chunking">Stacking / chunking</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../spark-stacking.html">Stacking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../spark-chunking.html">Chunking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../spark-api.html">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../spark-api.html#detailed-api">Detailed API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../local.html">Local</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../local-overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../local-api.html">API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../local-api.html#detailed-api">Detailed API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">bolt</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>bolt.spark.array</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for bolt.spark.array</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">unravel_index</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> \
    <span class="n">r_</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">random</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">ones</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>

<span class="kn">from</span> <span class="nn">bolt.base</span> <span class="kn">import</span> <span class="n">BoltArray</span>
<span class="kn">from</span> <span class="nn">bolt.spark.stack</span> <span class="kn">import</span> <span class="n">StackedArray</span>
<span class="kn">from</span> <span class="nn">bolt.spark.utils</span> <span class="kn">import</span> <span class="n">zip_with_index</span>
<span class="kn">from</span> <span class="nn">bolt.spark.statcounter</span> <span class="kn">import</span> <span class="n">StatCounter</span>
<span class="kn">from</span> <span class="nn">bolt.utils</span> <span class="kn">import</span> <span class="n">slicify</span><span class="p">,</span> <span class="n">listify</span><span class="p">,</span> <span class="n">tupleize</span><span class="p">,</span> <span class="n">argpack</span><span class="p">,</span> <span class="n">inshape</span><span class="p">,</span> <span class="n">istransposeable</span><span class="p">,</span> <span class="n">isreshapeable</span>


<div class="viewcode-block" id="BoltArraySpark"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark">[docs]</a><span class="k">class</span> <span class="nc">BoltArraySpark</span><span class="p">(</span><span class="n">BoltArray</span><span class="p">):</span>

    <span class="n">_metadata</span> <span class="o">=</span> <span class="n">BoltArray</span><span class="o">.</span><span class="n">_metadata</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;_shape&#39;</span><span class="p">,</span> <span class="s">&#39;_split&#39;</span><span class="p">,</span> <span class="s">&#39;_dtype&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span> <span class="o">=</span> <span class="n">rdd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split</span> <span class="o">=</span> <span class="n">split</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="s">&#39;spark&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BoltArraySpark</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

<div class="viewcode-block" id="BoltArraySpark.cache"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.cache">[docs]</a>    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cache the underlying RDD in memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.unpersist"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.unpersist">[docs]</a>    <span class="k">def</span> <span class="nf">unpersist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the underlying RDD from memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">unpersist</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.stack"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.stack">[docs]</a>    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregates records of a distributed array.</span>

<span class="sd">        Stacking should improve the performance of vectorized operations,</span>
<span class="sd">        but the resulting StackedArray object only exposes a restricted set</span>
<span class="sd">        of operations (e.g. map, reduce). The unstack method can be used</span>
<span class="sd">        to restore the full bolt array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : int, optional, default=None</span>
<span class="sd">            The maximum size for each stack (number of original records),</span>
<span class="sd">            will aggregate groups of records per partition up to this size,</span>
<span class="sd">            if None will aggregate all records on each partition.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        StackedArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stk</span> <span class="o">=</span> <span class="n">StackedArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stk</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align spark bolt array so that axes for iteration are in the keys.</span>

<span class="sd">        This operation is applied before most functional operators.</span>
<span class="sd">        It ensures that the specified axes are valid, and swaps</span>
<span class="sd">        key/value axes so that functional operators can be applied</span>
<span class="sd">        over the correct records.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis: tuple[int]</span>
<span class="sd">            One or more axes that wil be iterated over by a functional operator</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># ensure that the specified axes are valid</span>
        <span class="n">inshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c"># find the value axes that should be moved into the keys (axis &gt;= split)</span>
        <span class="n">tokeys</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">]</span>

        <span class="c"># find the key axes that should be moved into the values (axis &lt; split)</span>
        <span class="n">tovalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">tokeys</span> <span class="ow">or</span> <span class="n">tovalues</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">tovalues</span><span class="p">,</span> <span class="n">tokeys</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="BoltArraySpark.map"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function across an axis.</span>

<span class="sd">        Array will be aligned so that the desired set of axes</span>
<span class="sd">        are in the keys, which may incur a swap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function of a single array to apply</span>

<span class="sd">        axis : tuple or int, optional, default=(0,)</span>
<span class="sd">            Axis or multiple axes to apply function along.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c"># try to compute the size of each mapped element by applying func to a random array</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">swapped</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">swapped</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="c"># eval func on the first element</span>
                <span class="n">mapped</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">first</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">newshape</span> <span class="o">=</span> <span class="n">mapped</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">rdd</span> <span class="o">=</span> <span class="n">swapped</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="c"># reshaping will fail if the elements aren&#39;t uniformly shaped</span>
        <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">newshape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Map operation did not produce values of uniform shape.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="n">rdd</span> <span class="o">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">check</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">swapped</span><span class="o">.</span><span class="n">_shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">))]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">newshape</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="n">swapped</span><span class="o">.</span><span class="n">split</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">swapped</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.filter"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter array along an axis.</span>

<span class="sd">        Applies a function which should evaluate to boolean,</span>
<span class="sd">        along a single axis or multiple axes. Array will be</span>
<span class="sd">        aligned so that the desired set of axes are in the keys,</span>
<span class="sd">        which may incur a swap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function to apply, should return boolean</span>

<span class="sd">        axis : tuple or int, optional, default=(0,)</span>
<span class="sd">            Axis or multiple axes to filter along.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Filtering over multiple axes will not be &quot;</span>
                                      <span class="s">&quot;supported until SparseBoltArray is implemented.&quot;</span><span class="p">)</span>

        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="n">swapped</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="c"># count the resulting array in order to reindex (linearize) the keys</span>
        <span class="n">count</span><span class="p">,</span> <span class="n">zipped</span> <span class="o">=</span> <span class="n">zip_with_index</span><span class="p">(</span><span class="n">rdd</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">zipped</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">reindexed</span> <span class="o">=</span> <span class="n">zipped</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c"># since we can only filter over one axis, the remaining shape is always the following</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">swapped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">reindexed</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="n">swapped</span><span class="o">.</span><span class="n">split</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">swapped</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.reduce"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce an array along an axis.</span>

<span class="sd">        Applies a commutative/associative function of two</span>
<span class="sd">        arguments cumulatively to all arrays along an axis.</span>
<span class="sd">        Array will be aligned so that the desired set of axes</span>
<span class="sd">        are in the keys, which may incur a swap.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function of two arrays that returns a single array</span>

<span class="sd">        axis : tuple or int, optional, default=(0,)</span>
<span class="sd">            Axis or multiple axes to reduce along.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">bolt.local.array</span> <span class="kn">import</span> <span class="n">BoltArrayLocal</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">swapped</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="c"># the result of a reduce can also be a scalar</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
            <span class="c"># ndarrays with single values in them should be converted into scalars</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BoltArrayLocal</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a statistic over an axis.</span>

<span class="sd">        Can provide either a function (for use in a reduce)</span>
<span class="sd">        or a name (for use by a stat counter).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>

<span class="sd">        func : function, optional, default=None</span>
<span class="sd">            Function for reduce, see BoltArraySpark.reduce</span>

<span class="sd">        name : str</span>
<span class="sd">            A named statistic, see StatCounter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">func</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">bolt.local.array</span> <span class="kn">import</span> <span class="n">BoltArrayLocal</span>

            <span class="n">swapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">reducer</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

            <span class="n">counter</span> <span class="o">=</span> <span class="n">swapped</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>\
                             <span class="o">.</span><span class="n">mapPartitions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">[</span><span class="n">StatCounter</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="n">name</span><span class="p">)])</span>\
                             <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">reducer</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">BoltArrayLocal</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">toscalar</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Must specify either a function or a statistic name.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BoltArraySpark.mean"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mean of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;mean&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.var"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the variance of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;variance&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.std"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard deviation of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;stdev&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.sum"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">add</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.max"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">maximum</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">maximum</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.min"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum of the array over the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int, optional, default=None</span>
<span class="sd">            Axis to compute statistic over, if None</span>
<span class="sd">            will compute over all axes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">minimum</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">minimum</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.concatenate"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.concatenate">[docs]</a>    <span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arry</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join this array with another array.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        arry : ndarray, BoltArrayLocal, or BoltArraySpark</span>
<span class="sd">            Another array to concatenate with</span>

<span class="sd">        axis : int, optional, default=0</span>
<span class="sd">            The axis along which arrays will be joined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arry</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">bolt.spark.construct</span> <span class="kn">import</span> <span class="n">ConstructSpark</span>
            <span class="n">arry</span> <span class="o">=</span> <span class="n">ConstructSpark</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arry</span><span class="p">,</span> <span class="n">BoltArraySpark</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;other must be local array or spark array, got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">arry</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="bp">True</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">arry</span><span class="o">.</span><span class="n">shape</span><span class="p">))]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;all the input array dimensions except for &quot;</span>
                             <span class="s">&quot;the concatenation axis must match exactly&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="o">==</span> <span class="n">arry</span><span class="o">.</span><span class="n">split</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;two arrays must have the same split &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">key</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">arry</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">(</span><span class="n">key_func</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">concatenate</span> <span class="k">as</span> <span class="n">npconcatenate</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span>
            <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arry</span><span class="o">.</span><span class="n">_rdd</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">npconcatenate</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">shift</span><span class="p">)))</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">x</span>
                      <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">arry</span><span class="o">.</span><span class="n">shape</span><span class="p">))])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_getbasic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Basic indexing (for slices or ints).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">slicify</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span>
        <span class="n">key_slices</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">]</span>
        <span class="n">value_slices</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="n">check</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">kk</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="n">ss</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">kk</span> <span class="o">&lt;</span> <span class="n">ss</span><span class="o">.</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">mod</span><span class="p">(</span><span class="n">kk</span> <span class="o">-</span> <span class="n">ss</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">step</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">check</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key_slices</span><span class="p">)]</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">k</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="n">s</span><span class="o">.</span><span class="n">step</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key_slices</span><span class="p">)])</span>

        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">key_check</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="n">filtered</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">(</span><span class="n">key_func</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">value_slices</span><span class="p">]))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">ceil</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">step</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">index</span><span class="p">])</span>
        <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span>
        <span class="k">return</span> <span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">split</span>

    <span class="k">def</span> <span class="nf">_getadvanced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced indexing (for sets, lists, or ndarrays).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;shape mismatch: indexing arrays could not be broadcast &quot;</span>
                             <span class="s">&quot;together with shapes &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                             <span class="o">%</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]))</span>

        <span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">listify</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span>

        <span class="c"># build tuples with target indices</span>
        <span class="n">key_tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">]))</span>
        <span class="n">value_tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">:]))</span>

        <span class="c"># build dictionary to look up targets in values</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">value_tuples</span><span class="p">,</span> <span class="n">key_tuples</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">key_check</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">key_tuples</span>

        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">unravel_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c"># filter records based on key targets</span>
        <span class="n">filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">key_check</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c"># subselect and flatten records based on value targets (if they exist)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_tuples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">filtered</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">[(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flattened</span> <span class="o">=</span> <span class="n">filtered</span>

        <span class="c"># reindex</span>
        <span class="n">indexed</span> <span class="o">=</span> <span class="n">flattened</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="p">()</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kkv</span><span class="p">:</span> <span class="p">(</span><span class="n">key_func</span><span class="p">(</span><span class="n">kkv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">kkv</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">split</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">split</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an item from the array through indexing.</span>

<span class="sd">        Supports basic indexing with slices and ints, or advanced</span>
<span class="sd">        indexing with lists or ndarrays of integers.</span>
<span class="sd">        Mixing basic and advanced indexing across axes is not</span>
<span class="sd">        currently supported.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : tuple of slices, ints, list, sets, or ndarrays</span>
<span class="sd">            One or more index specifications</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltSparkArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Too many indices for array&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Each index must either be a slice, int, list, set, or ndarray&quot;</span><span class="p">)</span>

        <span class="c"># fill unspecified axes with full slices</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">))])</span>

        <span class="c"># convert ints to lists if not all ints and slices</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">])</span>

        <span class="c"># select basic or advanced indexing</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getbasic</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getadvanced</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot mix basic indexing (slices and ints) with &quot;</span>
                                      <span class="s">&quot;advanced indexing (lists and ndarrays) across axes&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="n">split</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># squeeze out int dimensions (and squeeze to singletons if all ints)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tosqueeze</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tosqueeze</span><span class="p">)</span>

<div class="viewcode-block" id="BoltArraySpark.chunk"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.chunk">[docs]</a>    <span class="k">def</span> <span class="nf">chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;150&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Chunks records of a distributed array.</span>

<span class="sd">        Chunking breaks arrays into subarrays, using an specified</span>
<span class="sd">        number of chunks along each value dimension. Can alternatively</span>
<span class="sd">        specify an average chunk size (in megabytes) and the number of</span>
<span class="sd">        chunks will be computed automatically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : tuple, int, or str, optional, default = &quot;150&quot;</span>
<span class="sd">            A string giving the size in megabytes, or a tuple with the number</span>
<span class="sd">            of chunks along each dimension.</span>

<span class="sd">        axis : int or tuple, optional, default = None</span>
<span class="sd">            One or more axis to chunk array along, if None</span>
<span class="sd">            will use all axes,</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ChunkedArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">((</span><span class="n">size</span><span class="p">))</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">((</span><span class="n">axis</span><span class="p">))</span>

        <span class="kn">from</span> <span class="nn">bolt.spark.chunk</span> <span class="kn">import</span> <span class="n">ChunkedArray</span>

        <span class="n">chnk</span> <span class="o">=</span> <span class="n">ChunkedArray</span><span class="p">(</span><span class="n">rdd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chnk</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.swap"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.swap">[docs]</a>    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kaxes</span><span class="p">,</span> <span class="n">vaxes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s">&quot;150&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap axes from keys to values.</span>

<span class="sd">        This is the core operation underlying shape manipulation</span>
<span class="sd">        on the Spark bolt array. It exchanges an arbitrary set of axes</span>
<span class="sd">        between the keys and the valeus. If either is None, will only</span>
<span class="sd">        move axes in one direction (from keys to values, or values to keys).</span>
<span class="sd">        Keys moved to values will be placed immediately after the split; </span>
<span class="sd">        values moved to keys will be placed immediately before the split.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kaxes : tuple</span>
<span class="sd">            Axes from keys to move to values</span>

<span class="sd">        vaxes : tuple</span>
<span class="sd">            Axes from values to move to keys</span>

<span class="sd">        size : tuple or int, optional, default = &quot;150&quot;</span>
<span class="sd">            Can either provide a string giving the size in megabytes,</span>
<span class="sd">            or a tuple with the number of chunks along each</span>
<span class="sd">            value dimension being moved</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BoltArraySpark</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kaxes</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">tupleize</span><span class="p">(</span><span class="n">kaxes</span><span class="p">),</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">vaxes</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">tupleize</span><span class="p">(</span><span class="n">vaxes</span><span class="p">),</span> <span class="s">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kaxes</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vaxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot perform a swap that would &#39;</span>
                             <span class="s">&#39;end up with all data on a single key&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kaxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vaxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

        <span class="kn">from</span> <span class="nn">bolt.spark.chunk</span> <span class="kn">import</span> <span class="n">ChunkedArray</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">ChunkedArray</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span><span class="p">)</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">vaxes</span><span class="p">)</span>
        <span class="n">barray</span> <span class="o">=</span> <span class="n">chunks</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">kaxes</span><span class="p">,</span> <span class="n">vaxes</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">barray</span><span class="o">.</span><span class="n">_rdd</span> <span class="o">=</span> <span class="n">barray</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
            <span class="n">barray</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="n">barray</span><span class="o">.</span><span class="n">_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">barray</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.transpose"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.transpose">[docs]</a>    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array with the axes transposed.</span>

<span class="sd">        This operation will incur a swap unless the</span>
<span class="sd">        desiured permutation can be obtained</span>
<span class="sd">        only by transpoing the keys or the values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : None, tuple of ints, or n ints</span>
<span class="sd">            If None, will reverse axis order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">argpack</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>

        <span class="n">istransposeable</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="n">split</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span>

        <span class="c"># compute the keys/value axes that need to be swapped</span>
        <span class="n">new_keys</span><span class="p">,</span> <span class="n">new_values</span> <span class="o">=</span> <span class="n">p</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">split</span><span class="p">:]</span>
        <span class="n">swapping_keys</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="n">new_values</span> <span class="o">&lt;</span> <span class="n">split</span><span class="p">])</span>
        <span class="n">swapping_values</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">new_keys</span><span class="p">[</span><span class="n">new_keys</span> <span class="o">&gt;=</span> <span class="n">split</span><span class="p">])</span>
        <span class="n">stationary_keys</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">new_keys</span><span class="p">[</span><span class="n">new_keys</span> <span class="o">&lt;</span> <span class="n">split</span><span class="p">])</span>
        <span class="n">stationary_values</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">new_values</span><span class="p">[</span><span class="n">new_values</span> <span class="o">&gt;=</span> <span class="n">split</span><span class="p">])</span>
        
        <span class="c"># compute the permutation that the swap causes</span>
        <span class="n">p_swap</span> <span class="o">=</span> <span class="n">r_</span><span class="p">[</span><span class="n">stationary_keys</span><span class="p">,</span> <span class="n">swapping_values</span><span class="p">,</span> <span class="n">swapping_keys</span><span class="p">,</span> <span class="n">stationary_values</span><span class="p">]</span>

        <span class="c"># compute the extra permutation (p_x)  on top of this that needs to happen to get the full permutation desired</span>
        <span class="n">p_swap_inv</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">p_swap</span><span class="p">)</span>
        <span class="n">p_x</span> <span class="o">=</span> <span class="n">p_swap_inv</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="n">p_keys</span><span class="p">,</span> <span class="n">p_values</span> <span class="o">=</span> <span class="n">p_x</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">p_x</span><span class="p">[</span><span class="n">split</span><span class="p">:]</span><span class="o">-</span><span class="n">split</span>

        <span class="c"># perform the swap and the the within key/value permutations</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">swapping_keys</span><span class="p">,</span> <span class="n">swapping_values</span><span class="o">-</span><span class="n">split</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p_keys</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">p_values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
        
        <span class="k">return</span> <span class="n">arr</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transpose by reversing the order of the axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="BoltArraySpark.swapaxes"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array with two axes interchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis1 : int</span>
<span class="sd">            The first axis to swap</span>

<span class="sd">        axis2 : int</span>
<span class="sd">            The second axis to swap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">p</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis2</span>
        <span class="n">p</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.reshape"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array with the same data but a new shape.</span>

<span class="sd">        Currently only supports reshaping that independently</span>
<span class="sd">        reshapes the keys, or the values, or both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape :  tuple of ints, or n ints</span>
<span class="sd">            New shape</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">argpack</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">isreshapeable</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshapebasic</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Currently no support for reshaping between &quot;</span>
                                      <span class="s">&quot;keys and values for BoltArraySpark&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_key_shape</span><span class="p">,</span> <span class="n">new_value_shape</span> <span class="o">=</span> <span class="n">new</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_key_shape</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_value_shape</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_reshapebasic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the requested reshape can be broken into independant reshapes</span>
<span class="sd">        on the keys and values. If it can, returns the index in the new shape</span>
<span class="sd">        separating keys from values, otherwise returns -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">tupleize</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">old_key_size</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">old_value_size</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">)):</span>
            <span class="n">new_key_size</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">new</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new_value_size</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">new_key_size</span> <span class="o">==</span> <span class="n">old_key_size</span> <span class="ow">and</span> <span class="n">new_value_size</span> <span class="o">==</span> <span class="n">old_value_size</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<div class="viewcode-block" id="BoltArraySpark.squeeze"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.squeeze">[docs]</a>    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove one or more single-dimensional axes from the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : tuple or int</span>
<span class="sd">            One or more singleton axes to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">d</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]):</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">drop</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">drop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">((</span><span class="n">axis</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">drop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;an integer or tuple is required for the axis&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot select an axis to squeeze out which has size greater than one&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">):</span>
            <span class="n">kmask</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">drop</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">])</span>
            <span class="n">kfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">kk</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">ii</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kmask</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">):</span>
            <span class="n">vmask</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">drop</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">])</span>
            <span class="n">vfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">vmask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span>

        <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="p">(</span><span class="n">kfunc</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">vfunc</span><span class="p">(</span><span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">ss</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">ss</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">ii</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">])</span>
        <span class="n">split</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">split</span><span class="o">=</span><span class="n">split</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.astype"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast the array to a specified type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or dtype</span>
<span class="sd">            Typecode or data-type to cast the array to (see numpy)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rdd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">rdd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Size of each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Total number of elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Axis at which the array is split into keys/values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Data-type of array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a restricted keys.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">bolt.spark.shapes</span> <span class="kn">import</span> <span class="n">Keys</span>
        <span class="k">return</span> <span class="n">Keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">bolt.spark.shapes</span> <span class="kn">import</span> <span class="n">Values</span>
        <span class="k">return</span> <span class="n">Values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="BoltArraySpark.tolocal"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.tolocal">[docs]</a>    <span class="k">def</span> <span class="nf">tolocal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a local bolt array by first collecting as an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">bolt.local.array</span> <span class="kn">import</span> <span class="n">BoltArrayLocal</span>
        <span class="k">return</span> <span class="n">BoltArrayLocal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.toarray"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.toarray">[docs]</a>    <span class="k">def</span> <span class="nf">toarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the contents as a local array.</span>

<span class="sd">        Will likely cause memory problems for large objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.tordd"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.tordd">[docs]</a>    <span class="k">def</span> <span class="nf">tordd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the underlying RDD of the bolt array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span>
</div>
<div class="viewcode-block" id="BoltArraySpark.display"><a class="viewcode-back" href="../../../spark-api.html#bolt.spark.array.BoltArraySpark.display">[docs]</a>    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Show a pretty-printed representation of this BoltArrayLocal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rdd</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div></div></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>